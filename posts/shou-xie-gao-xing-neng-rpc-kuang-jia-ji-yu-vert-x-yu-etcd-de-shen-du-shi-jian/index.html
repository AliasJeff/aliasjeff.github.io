<!DOCTYPE html>
<html lang="en" class="dark light">

    <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="base" content="https:&#x2F;&#x2F;aliasjeff.github.io" />

    

    

    
    
    
        <title>
            
                手写高性能 RPC 框架：基于 Vert.x 与 Etcd 的深度实践
            
        </title>

        
            <meta property="og:title"
                  content="手写高性能 RPC 框架：基于 Vert.x 与 Etcd 的深度实践" />
        
    

    
        
    

    
        
    

    
    
        <link rel="icon"
              type="image/png"
              href="https://aliasjeff.github.io/code.svg" />
    

    
    
        <link href=https://aliasjeff.github.io/fonts.css rel="stylesheet" />
    

    
    

    
    

    
    
        <script defer src=https://aliasjeff.github.io/js/codeblock.js></script>
    

    
    
        <script defer src=https://aliasjeff.github.io/js/toc.js></script>
    

    
    
        <script defer src=https://aliasjeff.github.io/js/note.js></script>
    

    

    
    


    
    
        <link rel="stylesheet"
              type="text/css"
              href="https://aliasjeff.github.io/theme/light.css" />
        <link id="darkModeStyle"
              rel="stylesheet"
              type="text/css"
              href="https://aliasjeff.github.io/theme/dark.css" />
    

    <!-- Set the correct theme in the script -->

    
        <script src=https://aliasjeff.github.io/js/themetoggle.js></script>

        
            <script>
                setTheme(getSavedTheme());
            </script>
        
    


    <link rel="stylesheet"
          type="text/css"
          media="screen"
          href="https://aliasjeff.github.io/main.css" />

    

    
        <script defer
                src="https://aliasjeff.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e"></script></head>


    <body>
        <div class="left-content">
            
            
        </div>

        <div class="content">
            <nav>
    <div class="left-nav">
        
            <a href=https:&#x2F;&#x2F;aliasjeff.github.io>AliasJeff</a>
        


        <div class="socials">
            
                
            
            
                <a rel='me' href="https:&#x2F;&#x2F;github.com&#x2F;AliasJeff&#x2F;" class="social">
                    <img alt="github"
                         src="https://aliasjeff.github.io/icons/social/github.svg" />
                </a>
            
        </div>
    </div>

    <div class="right-nav">
        
            <a href=https://aliasjeff.github.io style="margin-right: 0.5em">Home</a>
        
            <a href=https://aliasjeff.github.io/posts style="margin-right: 0.5em">Posts</a>
        
            <a href=https://aliasjeff.github.io/about style="margin-right: 0.5em">About</a>
        
            <a href=https://aliasjeff.github.io/projects style="margin-right: 0.5em">Projects</a>
        
            <a href=https://aliasjeff.github.io/resume style="margin-right: 0.5em">Résumé</a>
        
            <a href=https://aliasjeff.github.io/tags style="margin-right: 0.5em">Tags</a>
        

        
            <button id="search-button"
                    class="search-button"
                    title="$SHORTCUT to open search">
                <img src="https://aliasjeff.github.io/icons/search.svg"
                     alt="Search"
                     class="search-icon" />
            </button>

            <div id="searchModal"
                 class="search-modal js"
                 role="dialog"
                 aria-labelledby="modalTitle">
                <div id="modal-content">
                    <h1 id="modalTitle" class="page-header">
                        Search
                    </h1>
                    <div id="searchBar">
                        <input id="searchInput"
                               role="combobox"
                               autocomplete="off"
                               spellcheck="false"
                               aria-expanded="false"
                               aria-controls="results-container"
                               placeholder="Search..." />
                        <button id="clear-search" class="clear-button" title="Clear search">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960">
                                <path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z" />
                            </svg>
                        </button>
                    </div>
                    <div id="results-container">
                        <div id="results-info">
                            <span id="zero_results" style="display: none;">No results</span>
                            <span id="one_result" style="display: none;">1 result</span>
                            <span id="many_results" style="display: none;">$NUMBER results</span>
                        </div>
                        <div id="results" role="listbox">
                        </div>
                    </div>
                </div>
            </div>
        

        
            <a id="dark-mode-toggle"
               onclick="toggleTheme(); event.preventDefault();"
               href="#">
                <img src="https://aliasjeff.github.io/icons/sun.svg" id="sun-icon" alt="Light" />
                <img src="https://aliasjeff.github.io/icons/moon.svg"
                     id="moon-icon"
                     style="filter: invert(1)"
                     alt="Dark" />
                <img src="https://aliasjeff.github.io/icons/auto.svg"
                     id="auto-icon"
                     style="filter: invert(1)"
                     alt="Auto" />
            </a>

            <!-- Initialize the theme toggle icons -->
            <script>
                updateItemToggleTheme()
            </script>
        
    </div>
</nav>


            
            
    
    <div class="visible-element-observer-root" data-selector="main article p">
        <main>
            <article>
                <div class="title">
                    
                    
    
        <div class="page-header">
            手写高性能 RPC 框架：基于 Vert.x 与 Etcd 的深度实践
        </div>
    


                    <div class="meta">
                        
                            Posted on <time>2024-12-03</time>
                        


                        

                        

                        

                        
                        

                        
                        

                        
                        
                            <span class="tags-label">::</span>
                            <span class="tags">
                                    <a href="https://aliasjeff.github.io/tags/jia-gou-she-ji/"
                                       class="post-tag">架构设计</a>
                                
                                    <a href="https://aliasjeff.github.io/tags/rpc/"
                                       class="post-tag">RPC</a>
                                
                            </span>
                        

                        

                    </div>
                </div>

                

                <section class="body">
                    <h2 id="1-qian-yan"><a class="zola-anchor" href="#1-qian-yan" aria-label="Anchor link for: 1-qian-yan">1. 前言</a></h2>
<p>在微服务架构盛行的今天，RPC（远程过程调用）框架是系统间通信的基石。虽然 Dubbo、gRPC 等成熟框架珠玉在前，但为了深入理解分布式系统的核心原理，我决定参考 Dubbo 的设计理念，基于 <strong>Vert.x</strong> 和 <strong>Etcd</strong> 自主研发一套轻量级、可扩展、高性能的 RPC 框架。</p>
<p>本框架的核心目标是<strong>高扩展性</strong>与<strong>高性能</strong>。通过自定义 TCP 协议解决网络传输瓶颈，利用 Java SPI 机制实现插件化架构，并借助 Etcd 实现强一致性的服务发现。</p>
<hr />
<h2 id="2-he-xin-jia-gou-she-ji"><a class="zola-anchor" href="#2-he-xin-jia-gou-she-ji" aria-label="Anchor link for: 2-he-xin-jia-gou-she-ji">2. 核心架构设计</a></h2>
<p>项目采用分层架构设计，各层之间松耦合，便于后续扩展。主要包含以下几个核心模块：</p>
<ul>
<li><strong>服务层</strong>：基于 Spring Boot Starter 实现注解驱动（<code>@RpcService</code>, <code>@RpcReference</code>），对业务代码零侵入。</li>
<li><strong>注册中心层</strong>：基于 Etcd 实现服务的注册、发现、心跳检测与动态感知。</li>
<li><strong>代理层</strong>：封装网络传输细节，通过 JDK 动态代理实现像调用本地方法一样调用远程服务。</li>
<li><strong>传输层</strong>：基于 Vert.x 实现高性能 TCP 服务器，解决半包粘包问题。</li>
<li><strong>序列化层</strong>：支持多种序列化算法（Kryo, Hessian, JSON），通过 SPI 动态加载。</li>
</ul>
<hr />
<h2 id="3-guan-jian-ji-shu-pou-xi-yu-shi-xian"><a class="zola-anchor" href="#3-guan-jian-ji-shu-pou-xi-yu-shi-xian" aria-label="Anchor link for: 3-guan-jian-ji-shu-pou-xi-yu-shi-xian">3. 关键技术剖析与实现</a></h2>
<h3 id="3-1-gao-xing-neng-wang-luo-tong-xin-wei-shen-me-xuan-ze-vert-x"><a class="zola-anchor" href="#3-1-gao-xing-neng-wang-luo-tong-xin-wei-shen-me-xuan-ze-vert-x" aria-label="Anchor link for: 3-1-gao-xing-neng-wang-luo-tong-xin-wei-shen-me-xuan-ze-vert-x">3.1 高性能网络通信：为什么选择 Vert.x？</a></h3>
<p>在网络传输选型上，项目初期尝试过 HTTP 协议，但 HTTP 头部冗余严重，且无状态特性导致性能上限受限。最终，我选择了 <strong>自定义 TCP 协议 + Vert.x</strong>。</p>
<ul>
<li><strong>Vert.x 的优势</strong>：不同于 Netty 的底层复杂性，Vert.x 提供了更高层次的 Reactor 模型抽象。它是全异步非阻塞的，利用 EventLoop 机制，单线程即可处理高并发连接，极大地减少了线程上下文切换的开销。</li>
</ul>
<h3 id="3-1-1-zi-ding-yi-xie-yi-she-ji"><a class="zola-anchor" href="#3-1-1-zi-ding-yi-xie-yi-she-ji" aria-label="Anchor link for: 3-1-1-zi-ding-yi-xie-yi-she-ji">3.1.1 自定义协议设计</a></h3>
<p>为了防止网络攻击并确保数据完整性，我设计了一套私有协议：</p>
<table><thead><tr><th><strong>字段</strong></th><th><strong>长度</strong></th><th><strong>说明</strong></th></tr></thead><tbody>
<tr><td>Magic Number</td><td>1 Byte</td><td>魔数，用于快速校验是否为本框架数据包</td></tr>
<tr><td>Version</td><td>1 Byte</td><td>协议版本号</td></tr>
<tr><td>Serializer</td><td>1 Byte</td><td>序列化算法标识 (1-JSON, 2-Kryo, 3-Hessian)</td></tr>
<tr><td>Type</td><td>1 Byte</td><td>消息类型 (请求/响应/心跳)</td></tr>
<tr><td>Status</td><td>1 Byte</td><td>状态码</td></tr>
<tr><td>Request ID</td><td>8 Bytes</td><td>请求ID，用于异步请求的响应匹配</td></tr>
<tr><td>Body Length</td><td>4 Bytes</td><td>数据体长度</td></tr>
<tr><td>Body</td><td>Variable</td><td>序列化后的请求数据</td></tr>
</tbody></table>
<h3 id="3-1-2-jie-jue-tcp-ban-bao-yu-nian-bao"><a class="zola-anchor" href="#3-1-2-jie-jue-tcp-ban-bao-yu-nian-bao" aria-label="Anchor link for: 3-1-2-jie-jue-tcp-ban-bao-yu-nian-bao">3.1.2 解决 TCP 半包与粘包</a></h3>
<p>TCP 是流式协议，没有边界。我使用了 <strong>装饰者模式</strong> 对 Vert.x 的 <code>RecordParser</code> 进行了封装。</p>
<pre data-lang="java" class="language-java "><code class="language-java" data-lang="java">&#x2F;&#x2F; 装饰者模式封装 RecordParser
public class TcpBufferHandlerWrapper implements Handler&lt;Buffer&gt; {
    private final RecordParser recordParser;

    public TcpBufferHandlerWrapper(Handler&lt;Buffer&gt; bufferHandler) {
        &#x2F;&#x2F; 初始化 Parser，先读取固定长度的头部信息
        this.recordParser = RecordParser.newFixed(ProtocolConstant.HEADER_LENGTH);
        this.recordParser.setOutput(new Handler&lt;Buffer&gt;() {
            int size = -1;
            Buffer resultBuffer = Buffer.buffer();

            @Override
            public void handle(Buffer buffer) {
                if (-1 == size) {
                    &#x2F;&#x2F; 读取头部，获取 body 长度
                    size = buffer.getInt(ProtocolConstant.BODY_LENGTH_OFFSET);
                    recordParser.fixedSizeMode(size); &#x2F;&#x2F; 动态调整下一次读取长度
                    resultBuffer.appendBuffer(buffer);
                } else {
                    &#x2F;&#x2F; 读取 Body，组装完整包
                    resultBuffer.appendBuffer(buffer);
                    bufferHandler.handle(resultBuffer);
                    &#x2F;&#x2F; 重置，准备读取下一个包
                    recordParser.fixedSizeMode(ProtocolConstant.HEADER_LENGTH);
                    size = -1;
                    resultBuffer = Buffer.buffer();
                }
            }
        });
    }

    @Override
    public void handle(Buffer buffer) {
        recordParser.handle(buffer);
    }
}
</code></pre>
<h3 id="3-2-kuo-zhan-xing-spi-ji-zhi"><a class="zola-anchor" href="#3-2-kuo-zhan-xing-spi-ji-zhi" aria-label="Anchor link for: 3-2-kuo-zhan-xing-spi-ji-zhi">3.2 扩展性：SPI 机制</a></h3>
<p>为了让框架支持替换组件（如更换序列化器或负载均衡策略），我实现了一套类似 Dubbo 的 SPI（Service Provider Interface）加载机制。</p>
<ul>
<li><strong>实现原理</strong>：
<ol>
<li>定义标准接口（如 <code>Serializer</code>）。</li>
<li>读取 <code>META-INF/rpc/system</code> 下的配置文件。</li>
<li>利用 <strong>双检锁单例模式</strong> 懒加载实例，并使用 <code>ConcurrentHashMap</code> 做缓存。</li>
</ol>
</li>
</ul>
<pre data-lang="java" class="language-java "><code class="language-java" data-lang="java">public class SpiLoader {
    &#x2F;&#x2F; 缓存加载的类：Map&lt;接口名, Map&lt;别名, 实现类&gt;&gt;
    private static final Map&lt;String, Map&lt;String, Class&lt;?&gt;&gt;&gt; loaderMap = new ConcurrentHashMap&lt;&gt;();
    &#x2F;&#x2F; 缓存实例：Map&lt;实现类, 实例&gt;
    private static final Map&lt;String, Object&gt; instanceCache = new ConcurrentHashMap&lt;&gt;();

    public static &lt;T&gt; T getInstance(Class&lt;T&gt; tClass, String key) {
        &#x2F;&#x2F; ... 省略非空校验
        Class&lt;?&gt; implClass = loaderMap.get(tClass.getName()).get(key);
        String implClassName = implClass.getName();
        
        &#x2F;&#x2F; 双检锁单例模式获取实例
        if (!instanceCache.containsKey(implClassName)) {
            synchronized (SpiLoader.class) {
                if (!instanceCache.containsKey(implClassName)) {
                    instanceCache.put(implClassName, implClass.newInstance());
                }
            }
        }
        return (T) instanceCache.get(implClassName);
    }
}
</code></pre>
<h3 id="3-3-zhu-ce-zhong-xin-etcd-de-shen-du-ying-yong"><a class="zola-anchor" href="#3-3-zhu-ce-zhong-xin-etcd-de-shen-du-ying-yong" aria-label="Anchor link for: 3-3-zhu-ce-zhong-xin-etcd-de-shen-du-ying-yong">3.3 注册中心：Etcd 的深度应用</a></h3>
<p>相比于 Eureka 的 AP 模型，Etcd 基于 Raft 算法保证了 CP（强一致性），更适合作为核心中间件的底座。</p>
<ul>
<li>
<p><strong>服务续期与下线</strong>：</p>
<ul>
<li>利用 Etcd 的 <code>Lease</code> (租约) 机制实现心跳。服务提供者启动时绑定一个租约，并定期续约。</li>
<li><strong>被动下线</strong>：一旦服务宕机，无法续约，TTL 过期后 Etcd 自动删除节点。</li>
<li><strong>主动下线</strong>：通过 JVM <code>Runtime.getRuntime().addShutdownHook</code> 钩子函数，在系统关闭时主动清除注册信息。</li>
</ul>
</li>
<li>
<p>消费端缓存与监听：</p>
<p>为了减少对 Etcd 的频繁访问，消费者端在本地缓存了服务列表。同时利用 Etcd 的 Watch 机制监听前缀，一旦服务上线或下线，实时更新本地缓存，实现了最终一致性。</p>
</li>
</ul>
<h3 id="3-4-fu-zai-jun-heng-yi-zhi-xing-hash-suan-fa"><a class="zola-anchor" href="#3-4-fu-zai-jun-heng-yi-zhi-xing-hash-suan-fa" aria-label="Anchor link for: 3-4-fu-zai-jun-heng-yi-zhi-xing-hash-suan-fa">3.4 负载均衡：一致性 Hash 算法</a></h3>
<p>为了解决节点动态上下线导致的数据倾斜问题，除了传统的轮询和随机策略，我重点实现了一致性 Hash 负载均衡器。</p>
<ul>
<li>
<p>核心逻辑：</p>
<p>使用 TreeMap 构建 Hash 环。为了避免节点过少导致的数据倾斜，引入了虚拟节点机制，将一个物理节点映射为多个虚拟节点散落在环上。</p>
</li>
</ul>
<pre data-lang="java" class="language-java "><code class="language-java" data-lang="java">public class ConsistentHashLoadBalancer implements LoadBalancer {
    private final TreeMap&lt;Integer, ServiceMetaInfo&gt; virtualNodes = new TreeMap&lt;&gt;();
    private static final int VIRTUAL_NODE_NUM = 100;

    @Override
    public ServiceMetaInfo select(Map&lt;String, Object&gt; requestParams, List&lt;ServiceMetaInfo&gt; serviceList) {
        for (ServiceMetaInfo service : serviceList) {
            for (int i = 0; i &lt; VIRTUAL_NODE_NUM; i++) {
                int hash = getHash(service.getServiceAddress() + &quot;#&quot; + i);
                virtualNodes.put(hash, service);
            }
        }
        &#x2F;&#x2F; 根据请求参数的 Hash 值选择节点
        int requestHash = getHash(requestParams);
        &#x2F;&#x2F; ceilingEntry 返回大于等于 key 的最小键值对，实现顺时针查找
        Map.Entry&lt;Integer, ServiceMetaInfo&gt; entry = virtualNodes.ceilingEntry(requestHash);
        if (entry == null) {
            entry = virtualNodes.firstEntry();
        }
        return entry.getValue();
    }
}
</code></pre>
<h3 id="3-5-dong-tai-dai-li-yu-spring-zheng-he"><a class="zola-anchor" href="#3-5-dong-tai-dai-li-yu-spring-zheng-he" aria-label="Anchor link for: 3-5-dong-tai-dai-li-yu-spring-zheng-he">3.5 动态代理与 Spring 整合</a></h3>
<p>为了让用户无感知地调用远程服务，使用了 JDK 动态代理。</p>
<ul>
<li><strong>代理工厂</strong>：<code>ProxyFactory.getProxy(interfaceClass)</code>。</li>
<li><strong>InvocationHandler</strong>：在 <code>invoke</code> 方法中，封装 Request 对象（包含 method, args 等），执行负载均衡选择节点，发送 TCP 请求，并同步等待结果。</li>
</ul>
<p>Spring Boot 整合：</p>
<p>编写自定义 Starter，通过 BeanPostProcessor 实现 Bean 的后置处理：</p>
<ul>
<li>扫描带有 <code>@RpcService</code> 的类，自动注册到 Etcd。</li>
<li>扫描带有 <code>@RpcReference</code> 的字段，自动注入动态代理生成的桩对象。</li>
</ul>
<hr />
<h2 id="4-rong-cuo-yu-zhong-shi-ji-zhi"><a class="zola-anchor" href="#4-rong-cuo-yu-zhong-shi-ji-zhi" aria-label="Anchor link for: 4-rong-cuo-yu-zhong-shi-ji-zhi">4. 容错与重试机制</a></h2>
<p>分布式系统中，网络抖动是常态。我集成了 <strong>Guava-Retrying</strong> 库，结合 SPI 提供了多种策略：</p>
<ol>
<li><strong>固定间隔重试</strong>：适用于短暂网络波动。</li>
<li><strong>指数退避重试</strong>：防止请求风暴雪崩。</li>
<li><strong>Fail-Safe（失败安全）</strong>：记录日志，不抛异常，适用于非关键业务。</li>
</ol>
<hr />
<h2 id="5-zong-jie-yu-zhan-wang"><a class="zola-anchor" href="#5-zong-jie-yu-zhan-wang" aria-label="Anchor link for: 5-zong-jie-yu-zhan-wang">5. 总结与展望</a></h2>
<p>本项目通过整合 Vert.x 的高性能网络模型、Etcd 的强一致性协调能力以及 Java SPI 的插件化机制，实现了一个功能完备的 RPC 框架。</p>
<p><strong>项目亮点总结：</strong></p>
<ul>
<li><strong>高性能</strong>：自定义 TCP 协议 + Vert.x Reactor 模型 + Kryo 序列化，最大化网络吞吐。</li>
<li><strong>高可用</strong>：Etcd 租约机制 + 自动/被动下线 + 负载均衡 + 容错重试。</li>
<li><strong>高扩展</strong>：全链路 SPI 机制，支持自定义序列化器、协议、负载均衡器。</li>
<li><strong>架构设计</strong>：熟练运用双检锁单例、装饰者、工厂、代理、观察者等多种设计模式。</li>
</ul>

                </section>
            </article>
        </main>
    </div>



            
                
            

            
                <div class="giscus">
                </div>
                <script src="https://giscus.app/client.js"
        data-repo="AliasJeff/alias-studio.github.io"
        data-repo-id="R_kgDOQs_HFw"
        data-category="General"
        data-category-id="DIC_kwDOQs_HF84C0Hvj"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async>
</script>

            
        </div>

        <div class="right-content">
            
    
    
        <div class="toc">
    <div class="heading">
        Table of Contents
    </div>
    <ul class="toc-list">
        
            <li class="parent">
                
                <a href="https://aliasjeff.github.io/posts/shou-xie-gao-xing-neng-rpc-kuang-jia-ji-yu-vert-x-yu-etcd-de-shen-du-shi-jian/#1-qian-yan">1. 前言</a>

                
            </li>
        
            <li class="parent">
                
                <a href="https://aliasjeff.github.io/posts/shou-xie-gao-xing-neng-rpc-kuang-jia-ji-yu-vert-x-yu-etcd-de-shen-du-shi-jian/#2-he-xin-jia-gou-she-ji">2. 核心架构设计</a>

                
            </li>
        
            <li class="parent">
                
                <a href="https://aliasjeff.github.io/posts/shou-xie-gao-xing-neng-rpc-kuang-jia-ji-yu-vert-x-yu-etcd-de-shen-du-shi-jian/#3-guan-jian-ji-shu-pou-xi-yu-shi-xian">3. 关键技术剖析与实现</a>

                
                    <ul>
                        
                            
                            <li>
                                <a href="https://aliasjeff.github.io/posts/shou-xie-gao-xing-neng-rpc-kuang-jia-ji-yu-vert-x-yu-etcd-de-shen-du-shi-jian/#3-1-gao-xing-neng-wang-luo-tong-xin-wei-shen-me-xuan-ze-vert-x">3.1 高性能网络通信：为什么选择 Vert.x？</a>
                            </li>

                            
                        
                            
                            <li>
                                <a href="https://aliasjeff.github.io/posts/shou-xie-gao-xing-neng-rpc-kuang-jia-ji-yu-vert-x-yu-etcd-de-shen-du-shi-jian/#3-1-1-zi-ding-yi-xie-yi-she-ji">3.1.1 自定义协议设计</a>
                            </li>

                            
                        
                            
                            <li>
                                <a href="https://aliasjeff.github.io/posts/shou-xie-gao-xing-neng-rpc-kuang-jia-ji-yu-vert-x-yu-etcd-de-shen-du-shi-jian/#3-1-2-jie-jue-tcp-ban-bao-yu-nian-bao">3.1.2 解决 TCP 半包与粘包</a>
                            </li>

                            
                        
                            
                            <li>
                                <a href="https://aliasjeff.github.io/posts/shou-xie-gao-xing-neng-rpc-kuang-jia-ji-yu-vert-x-yu-etcd-de-shen-du-shi-jian/#3-2-kuo-zhan-xing-spi-ji-zhi">3.2 扩展性：SPI 机制</a>
                            </li>

                            
                        
                            
                            <li>
                                <a href="https://aliasjeff.github.io/posts/shou-xie-gao-xing-neng-rpc-kuang-jia-ji-yu-vert-x-yu-etcd-de-shen-du-shi-jian/#3-3-zhu-ce-zhong-xin-etcd-de-shen-du-ying-yong">3.3 注册中心：Etcd 的深度应用</a>
                            </li>

                            
                        
                            
                            <li>
                                <a href="https://aliasjeff.github.io/posts/shou-xie-gao-xing-neng-rpc-kuang-jia-ji-yu-vert-x-yu-etcd-de-shen-du-shi-jian/#3-4-fu-zai-jun-heng-yi-zhi-xing-hash-suan-fa">3.4 负载均衡：一致性 Hash 算法</a>
                            </li>

                            
                        
                            
                            <li>
                                <a href="https://aliasjeff.github.io/posts/shou-xie-gao-xing-neng-rpc-kuang-jia-ji-yu-vert-x-yu-etcd-de-shen-du-shi-jian/#3-5-dong-tai-dai-li-yu-spring-zheng-he">3.5 动态代理与 Spring 整合</a>
                            </li>

                            
                        
                    </ul>
                
            </li>
        
            <li class="parent">
                
                <a href="https://aliasjeff.github.io/posts/shou-xie-gao-xing-neng-rpc-kuang-jia-ji-yu-vert-x-yu-etcd-de-shen-du-shi-jian/#4-rong-cuo-yu-zhong-shi-ji-zhi">4. 容错与重试机制</a>

                
            </li>
        
            <li class="parent">
                
                <a href="https://aliasjeff.github.io/posts/shou-xie-gao-xing-neng-rpc-kuang-jia-ji-yu-vert-x-yu-etcd-de-shen-du-shi-jian/#5-zong-jie-yu-zhan-wang">5. 总结与展望</a>

                
            </li>
        
    </ul>
</div>

    

        </div>
    </body>

</html>
