<!DOCTYPE html>
<html lang="en" class="dark light">

    <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="base" content="https:&#x2F;&#x2F;aliasjeff.github.io" />

    

    

    
    
    
        <title>
            
                一致性问题 (二) —— 单机事务和分布式事务
            
        </title>

        
            <meta property="og:title"
                  content="一致性问题 (二) —— 单机事务和分布式事务" />
        
    

    
        
    

    
        
    

    
    
        <link rel="icon"
              type="image/png"
              href="https://aliasjeff.github.io/code.svg" />
    

    
    
        <link href=https://aliasjeff.github.io/fonts.css rel="stylesheet" />
    

    
    

    
    

    
    
        <script defer src=https://aliasjeff.github.io/js/codeblock.js></script>
    

    
    
        <script defer src=https://aliasjeff.github.io/js/toc.js></script>
    

    
    
        <script defer src=https://aliasjeff.github.io/js/note.js></script>
    

    

    
    


    
    
        <link rel="stylesheet"
              type="text/css"
              href="https://aliasjeff.github.io/theme/light.css" />
        <link id="darkModeStyle"
              rel="stylesheet"
              type="text/css"
              href="https://aliasjeff.github.io/theme/dark.css" />
    

    <!-- Set the correct theme in the script -->

    
        <script src=https://aliasjeff.github.io/js/themetoggle.js></script>

        
            <script>
                setTheme(getSavedTheme());
            </script>
        
    


    <link rel="stylesheet"
          type="text/css"
          media="screen"
          href="https://aliasjeff.github.io/main.css" />

    

    
        <script defer
                src="https://aliasjeff.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e"></script></head>


    <body>
        <div class="left-content">
            
            
        </div>

        <div class="content">
            <nav>
    <div class="left-nav">
        
            <a href=https:&#x2F;&#x2F;aliasjeff.github.io>AliasJeff</a>
        


        <div class="socials">
            
                
            
            
                <a rel='me' href="https:&#x2F;&#x2F;github.com&#x2F;AliasJeff&#x2F;" class="social">
                    <img alt="github"
                         src="https://aliasjeff.github.io/icons/social/github.svg" />
                </a>
            
        </div>
    </div>

    <div class="right-nav">
        
            <a href=https://aliasjeff.github.io style="margin-right: 0.5em">Home</a>
        
            <a href=https://aliasjeff.github.io/posts style="margin-right: 0.5em">Posts</a>
        
            <a href=https://aliasjeff.github.io/about style="margin-right: 0.5em">About</a>
        
            <a href=https://aliasjeff.github.io/projects style="margin-right: 0.5em">Projects</a>
        
            <a href=https://aliasjeff.github.io/resume style="margin-right: 0.5em">Résumé</a>
        
            <a href=https://aliasjeff.github.io/tags style="margin-right: 0.5em">Tags</a>
        

        
            <button id="search-button"
                    class="search-button"
                    title="$SHORTCUT to open search">
                <img src="https://aliasjeff.github.io/icons/search.svg"
                     alt="Search"
                     class="search-icon" />
            </button>

            <div id="searchModal"
                 class="search-modal js"
                 role="dialog"
                 aria-labelledby="modalTitle">
                <div id="modal-content">
                    <h1 id="modalTitle" class="page-header">
                        Search
                    </h1>
                    <div id="searchBar">
                        <input id="searchInput"
                               role="combobox"
                               autocomplete="off"
                               spellcheck="false"
                               aria-expanded="false"
                               aria-controls="results-container"
                               placeholder="Search..." />
                        <button id="clear-search" class="clear-button" title="Clear search">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960">
                                <path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z" />
                            </svg>
                        </button>
                    </div>
                    <div id="results-container">
                        <div id="results-info">
                            <span id="zero_results" style="display: none;">No results</span>
                            <span id="one_result" style="display: none;">1 result</span>
                            <span id="many_results" style="display: none;">$NUMBER results</span>
                        </div>
                        <div id="results" role="listbox">
                        </div>
                    </div>
                </div>
            </div>
        

        
            <a id="dark-mode-toggle"
               onclick="toggleTheme(); event.preventDefault();"
               href="#">
                <img src="https://aliasjeff.github.io/icons/sun.svg" id="sun-icon" alt="Light" />
                <img src="https://aliasjeff.github.io/icons/moon.svg"
                     id="moon-icon"
                     style="filter: invert(1)"
                     alt="Dark" />
                <img src="https://aliasjeff.github.io/icons/auto.svg"
                     id="auto-icon"
                     style="filter: invert(1)"
                     alt="Auto" />
            </a>

            <!-- Initialize the theme toggle icons -->
            <script>
                updateItemToggleTheme()
            </script>
        
    </div>
</nav>


            
            
    
    <div class="visible-element-observer-root" data-selector="main article p">
        <main>
            <article>
                <div class="title">
                    
                    
    
        <div class="page-header">
            一致性问题 (二) —— 单机事务和分布式事务
        </div>
    


                    <div class="meta">
                        
                            Posted on <time>2025-12-05</time>
                        


                        

                        

                        

                        
                        

                        
                        

                        
                        
                            <span class="tags-label">::</span>
                            <span class="tags">
                                    <a href="https://aliasjeff.github.io/tags/yi-zhi-xing/"
                                       class="post-tag">一致性</a>
                                
                                    <a href="https://aliasjeff.github.io/tags/fen-bu-shi/"
                                       class="post-tag">分布式</a>
                                
                            </span>
                        

                        

                    </div>
                </div>

                

                <section class="body">
                    <h2 id="yi-qian-yan"><a class="zola-anchor" href="#yi-qian-yan" aria-label="Anchor link for: yi-qian-yan">一、前言</a></h2>
<p>在后端开发领域，数据一致性永远是核心议题。之前我们或许讨论过冗余数据存储中的一致性，也研究过分布式共识算法。但回归到业务开发的最前线，我们面临最频繁的挑战，往往源于事务处理。</p>
<p>无论是处理单体架构下的复杂业务，还是微服务架构下的跨服务调用，其核心诉求是一致的：保证状态转化的安全。也就是我们常说的，要么全部成功，要么全部失败。</p>
<p>本文将从单机数据库的底层机制出发，推演到分布式环境下的一致性困境与破局方案。</p>
<h2 id="er-dan-ji-shi-wu-de-ji-shi"><a class="zola-anchor" href="#er-dan-ji-shi-wu-de-ji-shi" aria-label="Anchor link for: er-dan-ji-shi-wu-de-ji-shi">二、单机事务的基石</a></h2>
<p>数据库事务的本质是一组操作的集合。这组操作是不可分割的，它们负责将数据库从一个一致性状态，转换到另一个一致性状态。</p>
<p>对于Java开发者而言，我们要理解的不仅仅是Spring中的<code>@Transactional</code>注解，更需要理解底层数据库（以MySQL InnoDB为例）是如何支撑起ACID特性的。因为单机事务的实现原理，往往是分布式事务设计思想的源头。</p>
<h3 id="2-1-ge-chi-xing-yu-bing-fa-kong-zhi"><a class="zola-anchor" href="#2-1-ge-chi-xing-yu-bing-fa-kong-zhi" aria-label="Anchor link for: 2-1-ge-chi-xing-yu-bing-fa-kong-zhi">2.1 隔离性与并发控制</a></h3>
<p>隔离性 Isolation 是为了解决并发执行时，不同事务之间的干扰问题。其本质是在并发场景下，通过控制数据的访问范围，实现不同级别的对外一致性。</p>
<h3 id="2-1-1-chang-jian-de-bing-fa-yi-chang"><a class="zola-anchor" href="#2-1-1-chang-jian-de-bing-fa-yi-chang" aria-label="Anchor link for: 2-1-1-chang-jian-de-bing-fa-yi-chang">2.1.1 常见的并发异常</a></h3>
<ul>
<li><strong>脏读</strong>：读取到了其他事务未提交的数据。如果前一个事务回滚，当前事务持有的数据就是脏数据。</li>
<li><strong>不可重复读</strong>：同一事务内，两次读取同一行数据，结果不一致。这是因为中间有其他事务提交了修改。</li>
<li><strong>幻读</strong>：同一事务内，同样的查询条件，第二次查询时发现结果集中多了或者少了一些行。</li>
</ul>
<h3 id="2-1-2-mysqlde-jie-jue-fang-an-mvccyu-suo"><a class="zola-anchor" href="#2-1-2-mysqlde-jie-jue-fang-an-mvccyu-suo" aria-label="Anchor link for: 2-1-2-mysqlde-jie-jue-fang-an-mvccyu-suo">2.1.2 MySQL的解决方案：MVCC与锁</a></h3>
<p>MySQL InnoDB引擎通过多版本并发控制 MVCC 和锁机制配合解决了上述问题。</p>
<ul>
<li>
<p>读屏障 MVCC：</p>
<p>MVCC本质是一种快照读。InnoDB通过Undo Log构建数据的历史版本链，并通过Read View 读视图来判断当前事务能看到哪个版本的数据。</p>
<ul>
<li>在<strong>读已提交 RC</strong>级别下，每次查询都会生成新的Read View，所以能看到最新的已提交数据。</li>
<li>在<strong>可重复读 RR</strong>级别下，只在第一次查询生成Read View，后续查询沿用，从而保证了可重复读。</li>
</ul>
</li>
<li>
<p>写屏障 锁机制：</p>
<p>对于写操作，必须串行化。</p>
<ul>
<li><strong>行锁 Record Lock</strong>：锁住具体的数据行。</li>
<li><strong>间隙锁 Gap Lock</strong>：锁住数据之间的间隙，防止其他事务插入新数据。这是解决幻读的关键手段。</li>
<li><strong>临键锁 Next-Key Lock</strong>：行锁+间隙锁，锁定左开右闭区间。</li>
</ul>
</li>
</ul>
<h3 id="2-2-yuan-zi-xing-yu-hui-gun"><a class="zola-anchor" href="#2-2-yuan-zi-xing-yu-hui-gun" aria-label="Anchor link for: 2-2-yuan-zi-xing-yu-hui-gun">2.2 原子性与回滚</a></h3>
<p>原子性 Atomicity 要求事务要么全做，要么全不做。</p>
<p>在单机场景下，Undo Log 是实现原子性的关键。</p>
<p>每当我们要修改一条数据时，InnoDB不仅会修改内存中的数据，还会生成一条对应的反向操作日志记录在Undo Log中。</p>
<ul>
<li>如果执行Insert，Undo Log就记录Delete。</li>
<li>如果执行Update，Undo Log就记录Update回旧值的SQL。</li>
</ul>
<p>一旦事务需要回滚，或者系统崩溃重启，数据库就可以利用Undo Log将数据恢复到事务开始前的状态。</p>
<h3 id="2-3-chi-jiu-xing-yu-xing-neng-ping-heng"><a class="zola-anchor" href="#2-3-chi-jiu-xing-yu-xing-neng-ping-heng" aria-label="Anchor link for: 2-3-chi-jiu-xing-yu-xing-neng-ping-heng">2.3 持久性与性能平衡</a></h3>
<p>持久性 Durability 保证事务一旦提交，修改就是永久的。</p>
<p>这里存在一个经典的矛盾：写磁盘太慢，写内存不可靠。</p>
<p>InnoDB采用了 WAL 预写日志 技术来平衡。</p>
<ol>
<li>修改数据时，先在内存 Buffer Pool 中修改。</li>
<li>同时将修改操作顺序写入 <strong>Redo Log</strong> 并落盘。</li>
<li>只要Redo Log写入成功，事务就视为提交成功。</li>
<li>内存中的脏页会由后台线程慢慢刷回磁盘数据文件。</li>
</ol>
<p>即使断电，利用Redo Log也能重放操作，恢复数据。</p>
<hr />
<h2 id="san-fen-bu-shi-huan-jing-de-hun-dun-yu-tiao-zhan"><a class="zola-anchor" href="#san-fen-bu-shi-huan-jing-de-hun-dun-yu-tiao-zhan" aria-label="Anchor link for: san-fen-bu-shi-huan-jing-de-hun-dun-yu-tiao-zhan">三、分布式环境的混沌与挑战</a></h2>
<p>当我们从单机走向分布式，面对的最大的敌人不再是磁盘IO，而是<strong>不可靠的网络</strong>和<strong>不可靠的时钟</strong>。</p>
<h3 id="3-1-bai-zhan-ting-shi-de-wang-luo"><a class="zola-anchor" href="#3-1-bai-zhan-ting-shi-de-wang-luo" aria-label="Anchor link for: 3-1-bai-zhan-ting-shi-de-wang-luo">3.1 拜占庭式的网络</a></h3>
<p>在分布式系统中，节点通信依赖网络。但网络是不可靠的，一次RPC请求的结果存在三种状态：</p>
<ol>
<li>成功。</li>
<li>失败。</li>
<li><strong>未知（超时）</strong>。</li>
</ol>
<p>当发生超时时，发送方无法确定请求是根本没发出去，还是请求处理了但响应丢了。这就迫使我们必须引入<strong>确认应答模式</strong>和<strong>重试机制</strong>。</p>
<script src=https://aliasjeff.github.io/js/mermaid.js></script>

<pre class="mermaid">
  sequenceDiagram
    participant A as 服务调用方
    participant B as 服务提供方
    A->>B: 发送请求
    alt 网络正常
        B-->>A: 返回成功
    else 请求丢失
        A->>A: 超时未收到响应
    else 响应丢失
        B->>B: 处理业务
        B--x A: 响应在网络中丢失
        A->>A: 超时未收到响应
    end
    Note right of A: 只要没收到明确回复，<br/>A就无法确定B的状态
</pre>
<h3 id="3-2-ce-bu-zhun-de-shi-zhong"><a class="zola-anchor" href="#3-2-ce-bu-zhun-de-shi-zhong" aria-label="Anchor link for: 3-2-ce-bu-zhun-de-shi-zhong">3.2 测不准的时钟</a></h3>
<p>每台服务器都有自己的本地时钟。NTP同步虽然能校准时间，但依然存在误差。在分布式数据库中，如果单纯依赖物理时钟来判断由于两个事务的先后顺序，可能会出现后发生的操作时间戳反而更小的情况。</p>
<p>因此，分布式系统常采用<strong>逻辑时钟</strong>（如Lamport时钟）或中心化的<strong>TSO 全局授时服务</strong>来保证全局顺序一致性。</p>
<hr />
<h2 id="si-fen-bu-shi-shi-wu-de-yuan-zi-xing-jie-jue-fang-an"><a class="zola-anchor" href="#si-fen-bu-shi-shi-wu-de-yuan-zi-xing-jie-jue-fang-an" aria-label="Anchor link for: si-fen-bu-shi-shi-wu-de-yuan-zi-xing-jie-jue-fang-an">四、分布式事务的原子性解决方案</a></h2>
<p>在分布式场景下，我们需要跨多个节点实现要么全做，要么全不做。业界演化出了两大类解决思路：<strong>强一致性的回滚模式</strong> 和 <strong>最终一致性的重试模式</strong>。</p>
<h3 id="4-1-qiang-yi-zhi-xing-lu-jing-er-jie-duan-ti-jiao-2pc"><a class="zola-anchor" href="#4-1-qiang-yi-zhi-xing-lu-jing-er-jie-duan-ti-jiao-2pc" aria-label="Anchor link for: 4-1-qiang-yi-zhi-xing-lu-jing-er-jie-duan-ti-jiao-2pc">4.1 强一致性路径：二阶段提交 2PC</a></h3>
<p>2PC Two-Phase Commit 是分布式事务最基础的协议。它引入了一个协调者来管理所有参与者。</p>
<ul>
<li><strong>阶段一 准备 Prepare</strong>：协调者询问所有参与者，你们准备好提交了吗？参与者执行本地事务，写Redo/Undo Log，但<strong>不提交</strong>，并锁住资源。</li>
<li><strong>阶段二 提交 Commit</strong>：如果所有参与者都回复Yes，协调者发送Commit命令；只要有一个回复No或超时，协调者发送Rollback命令。</li>
</ul>
<h3 id="4-1-1-luo-di-shi-xian-seata-atmo-shi"><a class="zola-anchor" href="#4-1-1-luo-di-shi-xian-seata-atmo-shi" aria-label="Anchor link for: 4-1-1-luo-di-shi-xian-seata-atmo-shi">4.1.1 落地实现：Seata AT模式</a></h3>
<p>Seata是阿里开源的分布式事务框架，其AT模式是目前Java生态中最流行的2PC改良版。它对业务代码几乎无侵入。</p>
<p>核心机制：</p>
<p>Seata在本地事务提交前，会先解析SQL，查询更新前的数据镜像 Before Image，执行更新后，再查询更新后的数据镜像 After Image。这两个镜像会作为回滚日志 Undo Log 存入数据库。</p>
<p>若需要回滚，Seata会利用Before Image还原数据。</p>
<p>若需要提交，Seata只需异步删除Undo Log即可。</p>
<blockquote>
<p>注意：AT模式虽然方便，但需要获取全局锁来防止脏写，这在高并发场景下会有性能损耗。</p>
</blockquote>
<h3 id="4-2-ye-wu-ceng-mian-de-2pc-tccmo-shi"><a class="zola-anchor" href="#4-2-ye-wu-ceng-mian-de-2pc-tccmo-shi" aria-label="Anchor link for: 4-2-ye-wu-ceng-mian-de-2pc-tccmo-shi">4.2 业务层面的2PC：TCC模式</a></h3>
<p>2PC和Seata AT模式是数据库层面的强一致，会长时间持有数据库锁。TCC Try-Confirm-Cancel 则是将锁的粒度上移到业务层面。</p>
<ul>
<li><strong>Try</strong>：资源检查和预留。例如冻结资金、预扣库存。</li>
<li><strong>Confirm</strong>：真正的业务执行。使用Try阶段预留的资源。</li>
<li><strong>Cancel</strong>：预留资源的释放。</li>
</ul>
<p><strong>代码示意</strong>：</p>
<pre data-lang="java" class="language-java "><code class="language-java" data-lang="java">public interface InventoryService {
    &#x2F;&#x2F; Try阶段: 预扣库存
    @TwoPhaseBusinessAction(name = &quot;deductInventory&quot;, commitMethod = &quot;confirmDeduct&quot;, rollbackMethod = &quot;cancelDeduct&quot;)
    boolean prepareDeduct(BusinessActionContext context, @BusinessActionContextParameter(paramName = &quot;productId&quot;) String productId, @BusinessActionContextParameter(paramName = &quot;count&quot;) int count);

    &#x2F;&#x2F; Confirm阶段: 真正扣减
    boolean confirmDeduct(BusinessActionContext context);

    &#x2F;&#x2F; Cancel阶段: 释放预留
    boolean cancelDeduct(BusinessActionContext context);
}
</code></pre>
<p>TCC 性能更好，因为不依赖数据库的长事务，但对业务侵入极大，每个接口都要写三套逻辑。</p>
<h3 id="4-3-zui-zhong-yi-zhi-xing-lu-jing-xiao-xi-dui-lie"><a class="zola-anchor" href="#4-3-zui-zhong-yi-zhi-xing-lu-jing-xiao-xi-dui-lie" aria-label="Anchor link for: 4-3-zui-zhong-yi-zhi-xing-lu-jing-xiao-xi-dui-lie">4.3 最终一致性路径：消息队列</a></h3>
<p>在很多高并发业务场景（如电商下单后发券、发通知），我们并不要求实时一致，只要求最终一致。这时，<strong>尽最大努力交付</strong>是更好的选择。</p>
<p>其核心逻辑是：<strong>重试</strong>。只要我不断重试，消息总能送达，操作总能执行成功。</p>
<p>但是，如何保证 本地事务提交 和 消息发送 这两个动作的原子性？这里有两种经典方案。</p>
<h3 id="4-3-1-ben-di-xiao-xi-biao"><a class="zola-anchor" href="#4-3-1-ben-di-xiao-xi-biao" aria-label="Anchor link for: 4-3-1-ben-di-xiao-xi-biao">4.3.1 本地消息表</a></h3>
<p>这是最稳健的方案，不依赖特定MQ的功能。</p>
<p><strong>流程</strong>：</p>
<ol>
<li>在业务库中创建一个<code>message</code>表。</li>
<li>业务操作和插入<code>message</code>表在同一个本地事务中完成。</li>
<li>事务提交后，业务数据和消息记录同时存在。</li>
<li>通过一个定时任务或者异步线程，扫描<code>message</code>表，将未发送的消息投递到MQ。</li>
<li>MQ消费成功后，回调删除或更新<code>message</code>表的状态。</li>
</ol>
<p><strong>SQL结构示例</strong>：</p>
<pre data-lang="sql" class="language-sql "><code class="language-sql" data-lang="sql">CREATE TABLE `local_message` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `msg_topic` varchar(64) NOT NULL,
  `msg_content` text,
  `status` tinyint DEFAULT &#x27;0&#x27; COMMENT &#x27;0:未发送, 1:已发送, 2:失败&#x27;,
  `retry_count` int DEFAULT &#x27;0&#x27;,
  `next_retry_time` datetime,
  PRIMARY KEY (`id`)
);
</code></pre>
<h3 id="4-3-2-shi-wu-xiao-xi-rocketmq"><a class="zola-anchor" href="#4-3-2-shi-wu-xiao-xi-rocketmq" aria-label="Anchor link for: 4-3-2-shi-wu-xiao-xi-rocketmq">4.3.2 事务消息 RocketMQ</a></h3>
<p>RocketMQ 提供了原生的事务消息支持，本质上是把 2PC 的思想应用到了消息发送上。</p>
<p><strong>流程</strong>：</p>
<ol>
<li><strong>发送半消息</strong>：Producer发一条Half Message给MQ，MQ收到后持久化但不投递给Consumer。</li>
<li><strong>执行本地事务</strong>：Producer执行本地业务逻辑。</li>
<li><strong>提交或回滚</strong>：
<ul>
<li>本地事务成功，发送Commit，MQ将消息改为可投递。</li>
<li>本地事务失败，发送Rollback，MQ删除该消息。</li>
</ul>
</li>
<li><strong>回查兜底</strong>：如果MQ长时间没收到Commit/Rollback，会反向查询Producer，确认本地事务的状态。</li>
</ol>
<script src=https://aliasjeff.github.io/js/mermaid.js></script>

<pre class="mermaid">
  sequenceDiagram
    participant App as 应用服务
    participant MQ as RocketMQ
    participant DB as 数据库

    App->>MQ: 1. 发送半消息(Half Msg)
    MQ-->>App: OK
    App->>DB: 2. 执行本地事务
    alt 事务成功
        App->>MQ: 3. Commit
        MQ->>Consumer: 投递消息
    else 事务失败
        App->>MQ: 3. Rollback
        MQ->>MQ: 删除消息
    else 网络超时/进程崩溃
        MQ->>App: 4. 回查事务状态
        App->>DB: 检查数据
        App->>MQ: 补发Commit/Rollback
    end
</pre>
<hr />
<h2 id="wu-fen-bu-shi-huan-jing-xia-de-ge-chi-xing-yu-chi-jiu-xing"><a class="zola-anchor" href="#wu-fen-bu-shi-huan-jing-xia-de-ge-chi-xing-yu-chi-jiu-xing" aria-label="Anchor link for: wu-fen-bu-shi-huan-jing-xia-de-ge-chi-xing-yu-chi-jiu-xing">五、分布式环境下的隔离性与持久性</a></h2>
<h3 id="5-1-fen-bu-shi-ge-chi-xing"><a class="zola-anchor" href="#5-1-fen-bu-shi-ge-chi-xing" aria-label="Anchor link for: 5-1-fen-bu-shi-ge-chi-xing">5.1 分布式隔离性</a></h3>
<p>在分布式环境下，隔离性通常演变成读写分离下的延迟问题。</p>
<p>例如，主库更新了库存，从库还没同步，用户读取从库发现库存还有，下单却失败。</p>
<p><strong>解决思路</strong>：</p>
<ol>
<li><strong>强制读主</strong>：对于一致性要求极高的关键数据（如金额、库存），强制走主库查询。</li>
<li><strong>全局一致性快照</strong>：如Google Spanner或OceanBase，利用TrueTime或全局时间戳服务，保证在任何节点都能读到一致的快照版本。</li>
</ol>
<h3 id="5-2-fen-bu-shi-chi-jiu-xing"><a class="zola-anchor" href="#5-2-fen-bu-shi-chi-jiu-xing" aria-label="Anchor link for: 5-2-fen-bu-shi-chi-jiu-xing">5.2 分布式持久性</a></h3>
<p>单机的持久性靠Redo Log，分布式的持久性靠<strong>多副本复制</strong>。</p>
<p>为了防止单节点故障导致数据丢失，数据通常会复制多份（如3副本）。这里涉及一致性算法（Paxos、Raft）。</p>
<ul>
<li><strong>强一致复制</strong>：写操作必须同步到所有副本才算成功。安全但慢。</li>
<li><strong>半同步复制</strong>：写操作同步到多数派（Quorum）即可。</li>
</ul>
<hr />
<h2 id="liu-zong-jie-yu-xuan-xing-jian-yi"><a class="zola-anchor" href="#liu-zong-jie-yu-xuan-xing-jian-yi" aria-label="Anchor link for: liu-zong-jie-yu-xuan-xing-jian-yi">六、总结与选型建议</a></h2>
<p>分布式事务是一剂猛药，能治病，也有副作用（性能下降、复杂度飙升）。作为资深开发，我们在做架构选型时，应遵循以下原则：</p>
<ol>
<li>
<p>能不用就不用。</p>
<p>如果业务能通过领域划分，聚合在同一个数据库内，利用本地事务解决，那是最好的。不要为了分布式而分布式。</p>
</li>
<li>
<p><strong>区分业务场景的容忍度</strong>。</p>
<ul>
<li><strong>强一致性场景</strong>（如金融转账）：必须保证实时一致。考虑 <strong>Seata AT</strong> 模式（开发成本低）或 <strong>TCC</strong> 模式（性能要求高）。</li>
<li><strong>最终一致性场景</strong>（如支付成功后发货、积分变更）：推荐使用 <strong>RocketMQ事务消息</strong> 或 <strong>本地消息表</strong>。这是互联网大厂最常用的解耦方案。</li>
</ul>
</li>
<li>
<p>设计可回滚与可补偿的业务。</p>
<p>无论选择哪种方案，业务代码的健壮性至关重要。你需要思考：如果重试一直失败怎么办？是否需要人工介入的死信队列？接口是否做好了幂等性设计？</p>
</li>
</ol>
<p>技术服务于业务。理解ACID的底层原理，掌握2PC、MQ等工具的适用边界，才能在复杂的分布式迷局中，构建出既稳健又高效的系统。</p>

                </section>
            </article>
        </main>
    </div>



            
                
            

            
                <div class="giscus">
                </div>
                <script src="https://giscus.app/client.js"
        data-repo="AliasJeff/alias-studio.github.io"
        data-repo-id="R_kgDOQs_HFw"
        data-category="General"
        data-category-id="DIC_kwDOQs_HF84C0Hvj"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async>
</script>

            
        </div>

        <div class="right-content">
            
    
    
        <div class="toc">
    <div class="heading">
        Table of Contents
    </div>
    <ul class="toc-list">
        
            <li class="parent">
                
                <a href="https://aliasjeff.github.io/posts/yi-zhi-xing-wen-ti-er-dan-ji-shi-wu-he-fen-bu-shi-shi-wu/#yi-qian-yan">一、前言</a>

                
            </li>
        
            <li class="parent">
                
                <a href="https://aliasjeff.github.io/posts/yi-zhi-xing-wen-ti-er-dan-ji-shi-wu-he-fen-bu-shi-shi-wu/#er-dan-ji-shi-wu-de-ji-shi">二、单机事务的基石</a>

                
                    <ul>
                        
                            
                            <li>
                                <a href="https://aliasjeff.github.io/posts/yi-zhi-xing-wen-ti-er-dan-ji-shi-wu-he-fen-bu-shi-shi-wu/#2-1-ge-chi-xing-yu-bing-fa-kong-zhi">2.1 隔离性与并发控制</a>
                            </li>

                            
                        
                            
                            <li>
                                <a href="https://aliasjeff.github.io/posts/yi-zhi-xing-wen-ti-er-dan-ji-shi-wu-he-fen-bu-shi-shi-wu/#2-1-1-chang-jian-de-bing-fa-yi-chang">2.1.1 常见的并发异常</a>
                            </li>

                            
                        
                            
                            <li>
                                <a href="https://aliasjeff.github.io/posts/yi-zhi-xing-wen-ti-er-dan-ji-shi-wu-he-fen-bu-shi-shi-wu/#2-1-2-mysqlde-jie-jue-fang-an-mvccyu-suo">2.1.2 MySQL的解决方案：MVCC与锁</a>
                            </li>

                            
                        
                            
                            <li>
                                <a href="https://aliasjeff.github.io/posts/yi-zhi-xing-wen-ti-er-dan-ji-shi-wu-he-fen-bu-shi-shi-wu/#2-2-yuan-zi-xing-yu-hui-gun">2.2 原子性与回滚</a>
                            </li>

                            
                        
                            
                            <li>
                                <a href="https://aliasjeff.github.io/posts/yi-zhi-xing-wen-ti-er-dan-ji-shi-wu-he-fen-bu-shi-shi-wu/#2-3-chi-jiu-xing-yu-xing-neng-ping-heng">2.3 持久性与性能平衡</a>
                            </li>

                            
                        
                    </ul>
                
            </li>
        
            <li class="parent">
                
                <a href="https://aliasjeff.github.io/posts/yi-zhi-xing-wen-ti-er-dan-ji-shi-wu-he-fen-bu-shi-shi-wu/#san-fen-bu-shi-huan-jing-de-hun-dun-yu-tiao-zhan">三、分布式环境的混沌与挑战</a>

                
                    <ul>
                        
                            
                            <li>
                                <a href="https://aliasjeff.github.io/posts/yi-zhi-xing-wen-ti-er-dan-ji-shi-wu-he-fen-bu-shi-shi-wu/#3-1-bai-zhan-ting-shi-de-wang-luo">3.1 拜占庭式的网络</a>
                            </li>

                            
                        
                            
                            <li>
                                <a href="https://aliasjeff.github.io/posts/yi-zhi-xing-wen-ti-er-dan-ji-shi-wu-he-fen-bu-shi-shi-wu/#3-2-ce-bu-zhun-de-shi-zhong">3.2 测不准的时钟</a>
                            </li>

                            
                        
                    </ul>
                
            </li>
        
            <li class="parent">
                
                <a href="https://aliasjeff.github.io/posts/yi-zhi-xing-wen-ti-er-dan-ji-shi-wu-he-fen-bu-shi-shi-wu/#si-fen-bu-shi-shi-wu-de-yuan-zi-xing-jie-jue-fang-an">四、分布式事务的原子性解决方案</a>

                
                    <ul>
                        
                            
                            <li>
                                <a href="https://aliasjeff.github.io/posts/yi-zhi-xing-wen-ti-er-dan-ji-shi-wu-he-fen-bu-shi-shi-wu/#4-1-qiang-yi-zhi-xing-lu-jing-er-jie-duan-ti-jiao-2pc">4.1 强一致性路径：二阶段提交 2PC</a>
                            </li>

                            
                        
                            
                            <li>
                                <a href="https://aliasjeff.github.io/posts/yi-zhi-xing-wen-ti-er-dan-ji-shi-wu-he-fen-bu-shi-shi-wu/#4-1-1-luo-di-shi-xian-seata-atmo-shi">4.1.1 落地实现：Seata AT模式</a>
                            </li>

                            
                        
                            
                            <li>
                                <a href="https://aliasjeff.github.io/posts/yi-zhi-xing-wen-ti-er-dan-ji-shi-wu-he-fen-bu-shi-shi-wu/#4-2-ye-wu-ceng-mian-de-2pc-tccmo-shi">4.2 业务层面的2PC：TCC模式</a>
                            </li>

                            
                        
                            
                            <li>
                                <a href="https://aliasjeff.github.io/posts/yi-zhi-xing-wen-ti-er-dan-ji-shi-wu-he-fen-bu-shi-shi-wu/#4-3-zui-zhong-yi-zhi-xing-lu-jing-xiao-xi-dui-lie">4.3 最终一致性路径：消息队列</a>
                            </li>

                            
                        
                            
                            <li>
                                <a href="https://aliasjeff.github.io/posts/yi-zhi-xing-wen-ti-er-dan-ji-shi-wu-he-fen-bu-shi-shi-wu/#4-3-1-ben-di-xiao-xi-biao">4.3.1 本地消息表</a>
                            </li>

                            
                        
                            
                            <li>
                                <a href="https://aliasjeff.github.io/posts/yi-zhi-xing-wen-ti-er-dan-ji-shi-wu-he-fen-bu-shi-shi-wu/#4-3-2-shi-wu-xiao-xi-rocketmq">4.3.2 事务消息 RocketMQ</a>
                            </li>

                            
                        
                    </ul>
                
            </li>
        
            <li class="parent">
                
                <a href="https://aliasjeff.github.io/posts/yi-zhi-xing-wen-ti-er-dan-ji-shi-wu-he-fen-bu-shi-shi-wu/#wu-fen-bu-shi-huan-jing-xia-de-ge-chi-xing-yu-chi-jiu-xing">五、分布式环境下的隔离性与持久性</a>

                
                    <ul>
                        
                            
                            <li>
                                <a href="https://aliasjeff.github.io/posts/yi-zhi-xing-wen-ti-er-dan-ji-shi-wu-he-fen-bu-shi-shi-wu/#5-1-fen-bu-shi-ge-chi-xing">5.1 分布式隔离性</a>
                            </li>

                            
                        
                            
                            <li>
                                <a href="https://aliasjeff.github.io/posts/yi-zhi-xing-wen-ti-er-dan-ji-shi-wu-he-fen-bu-shi-shi-wu/#5-2-fen-bu-shi-chi-jiu-xing">5.2 分布式持久性</a>
                            </li>

                            
                        
                    </ul>
                
            </li>
        
            <li class="parent">
                
                <a href="https://aliasjeff.github.io/posts/yi-zhi-xing-wen-ti-er-dan-ji-shi-wu-he-fen-bu-shi-shi-wu/#liu-zong-jie-yu-xuan-xing-jian-yi">六、总结与选型建议</a>

                
            </li>
        
    </ul>
</div>

    

        </div>
    </body>

</html>
